# CSS
## css盒模型
有两种：怪异模式盒模型和标准盒模型。
盒模型是由一个元素的 content padding border margin 组成
标准盒模型的宽高由 content 组成
怪异盒模型的宽高由 content padding border 组成
设置方式：
box-sizing: border-box(怪异盒模型)/content-box(标准盒模型)/inherit (从父元素继承 box-sizing的值)

## BFC
BFC，顾名思义，是块级格式化上下文。它是一个独立的渲染区域，区域内部元素与外部元素的样式布局互不影响，不被 float 元素覆盖，内部的盒子会按垂直方向一个一个放置，并且分属不同BFC时可以避免 margin 重叠，计算 BFC 高度时，浮动元素也会计算在内。

### 怎样生成 BFC ：
1. 根元素
2. float 不为 none
3. position 为 absolute/fixed
4. overflow 的值不为 visible
5. display 为 inline-block/flex等

## inline-block 元素之间有间隙
多行排列的 inline-block 元素之间有间隙，是因为两个标签之间有空格，浏览器会把这个空格当做文字的空格，这个就是有间隙的原因。

### 解决办法：
1. 让两个标签之间无间隙，但是排版不好
2. 给父元素添上 font-size: 0;

## 单行文本溢出显示省略号
text-overflow: ellipsis;
white-space: no-wrap; // 不换行

## 多行文本溢出显示省略号
text-overflow: ellipsis;

## display:none 和 visible:hidden 的区别
1. 两者都会在视觉上隐藏元素，但是 display: none 是直接把节点从 DOM 文档中移除再添上，而 visible:hidden 则是简单的隐藏元素，仍然保留了 DOM 中的位置。
2. 由于第 1 点，display:none 会引发回流，导致渲染树重新渲染然后重新布局绘制展示，代价较大。而 overflow:hidden 则会引发重绘，只是重新绘制该元素的节点信息。

## transform/transition/animation
只提我觉得需要注意的点
1. 分清 transform 是位移、缩放、旋转、倾斜/ transition 是过渡动画/animation 是复杂动画
2. transform: translate3d(x, y, z) 可以触发硬件加速。

> 什么是硬件加速,就是会给元素额外创建一个复杂图层，就是硬件加速。因为到最终展示页面的时候是 GPU进程 协助 GUI 渲染线程去展示页面的， GPU 进程会把各个图层合成后展示在页面上。(普通文档流是默认复合图层、absolute虽然脱离了文档流，但还是属于默认复合图层)

## css 优化、提高性能的方法
1. 多个 css 合并，尽量减少 http 请求
2. css sprite
3. 抽象提取公共样式、减少代码量
4. 压缩 css 代码

## css 选择器
- 标签选择
- id选择器
- class 选择器
- 后代选择 (div a)
- 子代选择 (div > a)
- 相邻选择 (div + a)
- 通配符选择 (*)
- 伪类选择
- 属性选择器

## position 有哪些值？ relative 和 absolute 的定位原点是
- static // 正常定位，元素的位置在文档流内正常定位
- relative // 相对定位，元素的位置相对自身的位置进行定位
- absolute // 绝对定位，元素的位置相对祖先元素中 position 非 static 的元素进行定位，如果没有就相对视口进行定位
- fixed // 固定定位，相对整个视口进行定位
- inherit // 规定从上一级元素继承 position 的值

## 什么是响应式设计，响应式设计的基本原理是什么
- 响应式设计就是网站能够兼容不同大小的终端，而不是为每一个终端都开发一个版本的代码。
- 基本原理就是利用 css3 的媒体查询，为不同尺寸的终端适配不同的样式

## 浮动与清除浮动
浮动：脱离文档流，直到挨着包容框或另一个浮动框的边缘，可以覆盖文档流内的元素但是对文字会形成文字包裹的效果。

清除浮动：
1. 浮动元素的 :after 伪类中定义个 content: '', clear:both
2. 在需要清除浮动的元素上定义 clear: both
3. 把需要清除浮动的元素变成 BFC

## opacity
- opacity: 0 会让元素透明度变为0（隐藏了元素），但是保留 DOM 位置，可以进行事件监听（比如可以点击，但是 visible: hidden就不能点击，只是隐藏了元素），并且 `opacity: 0` 和 `position:absolute` 一样都可以额外生成一个复合图层，系统会额外分配资源，当改变了复合图层内部元素的位置样式等信息时，会单独渲染，与普通文档流的默认复合图层没有关联。

- rgba() 和 opacity 的透明效果有什么不同：opacity 会改变元素及其内部子元素的整个透明度，而 rgba() 则只是作用于当前元素，改变当前元素的颜色或背景色。

## base64的使用
- 将小图片改为 base64 编码写入 css, 可以减少 HTTP 请求。
- base64 的体积约为原图体积的 3/4 。

## 水平居中
### 行内元素/文字居中
```css
.parent {
  text-align: center; // 此方法对 inline,inline-block都有效
}
```
### 块级元素水平居中
#### 1 定宽用 margin 0 auto
```css
.child {
  width: xxx; // 需要定宽
  margin: 0 auto;
}
```
#### 2 display:table + margin:0 auto 使得元素类似块级元素，并且宽度等于内容宽
```css
.child {
  display: table;
  margin: 0 auto;
}
```

#### 3 display: flex + margin:0 auto 
```css
.parent {
  display: flex;
}
.child {
  margin: 0 auto;
}
```

#### 4 absolute + margin-left 需要知道元素宽度
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  width: 100px;
  left: 50%;
  margin-left: -50px // 宽度的一半
}
```
#### 5 absolute + transform 无须知道元素宽度
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}
```

#### 6 flex 
```css
.parent {
  display: flex;
  justify-content: center;
}
```
### 多个块级元素水平居中
#### 1. 把他们都 display: inline-block 然后 父元素 text-align: center;

#### 2. flex 
```css
.parent {
  display: flex;
  justify-content: center;
}
```

## 垂直居中
###  行内元素/文本垂直居中 
设置 line-height 与 父元素高度相等就行

### 块级元素垂直居中
#### 1 已知元素高度，使用 aboslute + margin-top
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  height: 100px;
  top: 50%;
  margin-top: -50px;
}
```
#### 2 未知元素高度 absolute + transform
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
```

#### 3 flex
```css
.parent {
  display: flex;
  align-item: center;
}
```

#### 4 display: table-cell + vertical-align: center 转换为单元格
```css
.parent {
  display: table-cell;
  vertical-align: center;
}
```

## 水平垂直居中
### 行内元素/文本
同时运用父元素 text-align: center,并且子元素设置 line-height 与 父元素高度一样就可以了。

### 块级元素
#### 1 已知宽高，利用 absolute + margin 
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  width: 100px;
  height: 200px;
  top: 50%;
  left: 50%;
  margin-top: -200px;
  margin-left: -50px;
}
```
#### 2 已知宽高， absolute + margin
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  width: 100px;
  height: 100px;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  margin auto;
}
```

#### 3 已知宽高 absolute + calc 
```css
.parent {
  display: relative;
}
.child {
  display: absolute;
  width: 100px;
  height: 200px;
  top: calc(50% - 100px);
  left: calc(50% - 50px)
}
```

#### 4 未知宽高，可利用 absolute + transform
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

#### 5 未知宽高，利用 flex
```css
.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
```
真是太多了，我都不想写了= =...

## 布局

