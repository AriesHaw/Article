
![](https://user-gold-cdn.xitu.io/2019/4/19/16a3564893546359?w=616&h=420&f=png&s=30292)

由于js有自动垃圾回收机制，内存的分配和回收都实现了自动管理，所以不少jser都不太注意内存空间。但其实想要真正掌握js这门 “真·牛逼” 的语言，想对后续知识点理解更深刻，那么就得掌握内存空间相关知识。

JS运行的时候，会有栈内存（stack）和堆内存(heap)，当我们用new实例化一个类的时候，这个new出来的对象就保存在heap里面，而这个对象的引用则存储在stack里。程序通过stack里的引用找到这个对象。例如`var a = [1,2,3];`，a的值是存储在stack里的引用，heap里存储着内容为[1,2,3]的Array对象。当栈中的变量被重新赋值，原来在堆中存储的对象就会被释放，这个过程就叫垃圾回收。

简单来说：
+ 基础类型值存在 栈内存
+ 引用类型值存在 堆内存

**小tips:** **为什么基础类型值要放在栈中，引用类型值放在堆中？**
> 记住一句话：能量是守衡的，无非是时间换空间，空间换时间的问题 堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。

### 栈数据结构
栈数据结构的逻辑就是一句话：<font color=#A52A2A>先进后出，后进先出。</font>有个例子举得好，想想在乒乓球盒里取球和放球，如下图自己理解。

![](https://user-gold-cdn.xitu.io/2019/4/20/16a394e6b7cad6ac?w=700&h=550&f=png&s=103516)

### 堆数据结构(heap)

堆数据结构是一种树状结构，大部分时候是完全二叉树，使用一个数组就可以存储，利于存储并且便于索引。可以在很快的时间内找到需要的值。举个例子，不同书摆在书柜，知道书名可以很快找到该书。

#### 基础数据类型

js中的基础数据类型还记得吧：`undefined`、`null`、 `string`、`number`、`boolean`。还有ES6增加的`sympol`（暂不考虑）。

> 注意：基本数据类型的值都是按值访问的，我们可以直接操作保存在变量中实际的值。

### 堆内存与引用数据类型
除了以上6种基础数据类型外，就是引用数据类型了，如`Object类型`,`Array类型`,`Date类型`,`Function类型`等，统称为**Object类型**。

<font color=#A52A2A>对于引用数据类型，它的值是一个对象，这个对象保存在堆内存当中。</font>

> 注意： 引用数据类型是按引用访问的，所以我们不能直接操作保存在堆内存中的对象，而是要去操作对象对应的引用，类似于一个地址指针，指向保存在堆内存中的对象实际值。

举个例子说明
```js
var a = 1;
var b = 'sadhu';
var c = true;
var d = undefined;
var e = null;

var arr = [1, 2];
var obj = {
    place: 'heap'
}
```
在这个例子中，我们画个图说明：

![](https://user-gold-cdn.xitu.io/2019/4/20/16a3965fe5eaa0f4?w=1658&h=1048&f=png&s=158058)

当要访问堆内存空间的引用数据类型的值时，是先从stack里拿到引用，通过引用去取堆内存空间的值。

我们现在清楚了这流程后，可以来看一道面试题了：

```js
var a = 10;
var b = a;
b = 20;
console.log(a, b); // 10, 20 
// 这里仅仅把a的值复制给b
```
```js
var a = [1, 2, 3];
var b = a;
b.push(4);
console.log(a, b); //[1,2,3,4] [1,2,3,4]
// 因为这里是把a对应的指向 [1, 2, 3]的 引用 复制给了b。所以此时b和a都指向了 [1, 2, 3]。
```
### 内存空间管理与生命周期
那么这个自动垃圾收集机制的原理是什么呢？其实就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。

> 比如局部作用域中的局部变量在函数执行完毕后很容易被垃圾收集器回收。但是全局变量就比较难判断，所以尽量少用。

举个例子来理解js的内存生命周期：

```js
var a = 20;  // 在内存中给数值变量分配空间 
alert(a + 100);  // 使用内存
a = null; // 使用完毕之后，释放内存空间
```

由例子可看出，js的生命周期是：

1. 在定义变量的时候就为变量分配了所需的内存空间
2. 使用分配到的内存（读、写）
3. 不需要内存空间时将其释放、归还。

### 垃圾回收

在JavaScript中，最常用的是通过<font color=#A52A2A>标记清除</font>的算法来找到哪些对象是不再继续使用的，因此`a = null`其实仅仅只是做了一个释放引用的操作，让a原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。

还有种，现在浏览器不再使用的垃圾收集算法是<font color=#A52A2A>引用计数</font>

#### 引用计数算法
这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为**“对象有没有其他对象引用到它”**。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

**限制：循环引用**

这个简单的算法有一个限制，就是如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。

```js
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o
  return "azerty";
}
f();
// 两个对象被创建，并互相引用，形成了一个循环
// 他们被调用之后不会离开函数作用域
// 所以他们已经没有用了，可以被回收了
// 然而，引用计数算法考虑到他们互相都有至少一次引用，所以他们不会被回收

```

实际当中的例子：

IE 6, 7 对DOM对象进行引用计数回收。对他们来说，一个常见问题就是内存泄露：

```js
var div = document.createElement("div");
div.onclick = function(){
  doSomething();
}; 
// div有了一个引用指向事件处理属性onclick
// 事件处理里也有一个对div的引用可以在函数作用域中被访问到
// 这个循环引用会导致两个对象都不会被垃圾回收
```

IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Component Object Model，组件对象模型）对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。因此，即使IE的JavaScript引擎是使用标记清除策略来实现的，但JavaScript访问的COM对象依然是基于引用计数策略的。换句话说，**只要在IE中涉及COM对象，就会存在循环引用的问题**：

```js
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;
```
DOM元素与原生JavaScript对象之间创建了循环引用。由于存在这个循环引用，即使将例子中的DOM从页面中移除，它也永远不会被回收。

在不使用它们的时候手工断开连接：

```js
myObject.element = null;
element.someObject = null;
```
为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的JavaScript对象。

JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种算法仍然可能会导致问题。

#### 标记-清除算法 Mark and sweep

这个算法把“对象是否不再需要”简化定义为**“对象是否可以获得”**。

这个算法假定设置一个叫做根的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。

> 算法工作原理：
>
>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后它会去掉环境中的变量以及被环境中的变量引用的变量标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”（比如A、B循环引用了，C对象（从根开始找，能引用到）引用的对象是A，当C对象切断与A的引用后，AB就都会被回收）。

**循环引用不再是问题了**

在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。

**限制: 那些无法从根对象查询到的对象都将被清除**

尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。

### 内存泄漏

能导致内存泄漏的**一定是一定是一定只是**引用类型的变量，比如函数和其他自定义对象。而值类型的变量是不存在内存泄漏的，比如字符串、数字、布尔值等。

当我们用JavaScript代码创建一个引用类型的时候（以下简称对象），js引擎会在内存中开辟一块空间来存放数据，并把指针引用交给那个变量。内存是有限的，js引擎必须保证当开辟的对象没用的时候，把所分配的内存空间释放出来，这个过程叫做垃圾回收，负责回收的叫做垃圾回收器（GC）。

**内存泄漏**是指我们已经无法再通过js代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它。导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。

### 造成内存泄漏的主要原因与解决办法

#### 1、意外的全局变量

未定义的变量会在全局对象创建一个新变量，如下：
```js
function foo(arg) {
    bar = "this is a hidden global variable";
}
```
函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。

```js
function foo(arg) {
    window.bar = "this is an explicit global variable";
}
```

另一个意外的全局变量可能由 this 创建。
```js
function foo() {
    this.variable = "potential accidental global";
}

// Foo 调用自己，this 指向了全局对象（window）
// 而不是 undefined
foo();
```
解决办法：
在 JavaScript 文件头部加上` 'use strict'`，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，**确保用完以后**把它设置为 null 或者重新定义。

#### 2、被遗忘的计时器或回调函数
```js
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        // 处理 node 和 someResource
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
```
上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。

#### 3、脱离 DOM 的引用
有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用**都清除**。

```js
var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
};
function doStuff() {
    image.src = 'http://some.url/image';
    button.click();
    console.log(text.innerHTML);
    // 更多逻辑
}
function removeButton() {
    // 按钮是 body 的后代元素
    document.body.removeChild(document.getElementById('button'));
    // 此时，仍旧存在一个全局的 #button 的引用
    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。
}
```
此外还要考虑 DOM 树**内部**或**子节点**的引用问题。假如你的 JavaScript 代码中保存了表格某一个 <td> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 <td> 以外的其它节点。实际情况并非如此：此 <td> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 <td> 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。

#### 闭包真是造成内存泄漏的原因之一吗？
不是！

闭包只是其内部函数记住并访问了所在的词法作用域（以chrome的说法）,也会产生**较大的内存占用**，**但是**，和**内存泄漏**有关系吗？看着一些系列文总结说与内存泄漏有关系你们就觉得与内存泄漏有关系呀？硬说有关系那是上世纪某个版本IE的bug了。

看个例子：
```js
// 定义函数（分配内存）
var run = function () {

  // 定义一个巨大的数组
  var str = new Array(1000000).join('*');

  // 定义一个使用 str 的 闭包（该闭包是以高程的说法，此说法准确来说不算正确，不过也仅仅只是叫法问题。相关内容我会在接下来写文阐述。）
  var doSthWithStr = function () {
    if (str === 'something')
      console.log("Hi there");
  };

  // 调用这个闭包
  doSthWithStr();
};

// setInterval每隔 1 s 调用 run 函数，因此 run 不会被回收。
// 每次调用完 run 之后，由于内部没有外部对象引用，run内部的变量和闭包会被回收
// 所以不会出现内存一直增长的问题。
setInterval(run, 1000);
```
这例子不也应用闭包了，那咋没造成内存泄漏呢？

再来，改一下上面的例子变成内存泄漏：
```js
var run = function () {
  var str = new Array(1000000).join('*');
  var doSthWithStr = function () {
  if (str !== 'something')
    console.log("Hi there");
  };
  
  // setInterval每隔 1 s 调用 run 函数，因此 run 不会被回收。
  // 由于 doSthWithStr 作为回调函数传给了 setInterval，所以不会被回收
  // 而 str 在它的词法作用域中，并且在doSthWithStr函数内部有调用，所以也不会被回收(闭包只是造成在doSthWithStr中有访问到str，而因为doSthWithStr不会被回收，所以str才不会被回收。)
  // 因此内存占用会一直增长
  setInterval(doSthWithStr, 100);
};
setInterval(run, 1000);
```
你可以把上述代码粘贴到 chrome 的 console 中运行，然后打开 timeline tab，录制内存使用量。你会看到内存使用量以每秒 1 M 的速度增长。

![](https://user-gold-cdn.xitu.io/2019/4/21/16a3e9141e7d01eb?w=2442&h=388&f=png&s=83542)

再来看个例子：

```js
var fn = null;
function foo() {
    var a = 2;
    function innerFoo() {
        console.log(a);
    }
    fn = innerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn
}

function bar() {
    fn(); // 此处的保留的innerFoo的引用
}

foo();
bar(); // 2
```
关于此处，闭包仅仅只是让内部函数innerFoo里保留了对foo内(chrome的叫法)的变量对象中的值的访问。

foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过`fn = innerFoo`(造成内存泄漏的原因是这个)，函数innerFoo的引用被保留了下来，复制给了全局变量fn。那么标记清除就会从根（window）开始找，找到从根开始引用的对象fn，找到fn引用的对象innerFoo，所以innerFoo不会被GC回收，因为闭包能让内部函数innerFoo访问到foo的变量对象的值，所以foo的变量对象也被保留了下来。所以Foo()执行完毕之后，所占内存未被垃圾收集器释放。

关于此处更多的理解与例子：

1. 问答模式，里面有人答的很好。[js的闭包和回调到底怎么才会造成真的内存泄漏呢？](https://segmentfault.com/q/1010000000414875)
2. 贺师俊贺老[关于js闭包是否真的会造成内存泄漏？](https://www.zhihu.com/question/31078912)
3. [JS内存泄漏实例解析](https://juejin.im/post/5a8e7f6df265da4e832677ec)
4. [V8内存管理机制及垃圾回收](https://cnodejs.org/topic/577217ac889605241796f932)

### 如何排查内存泄漏

[阮老师有详细记录](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)

### 最后

为了预防内存泄露及持有不必要的内存，应记得在函数结尾或适宜的时候对不需要引用的对象进行释放。为了确保有效地回收内存，应及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。

本文完。

希望看到各位技术人对这篇文章有不同的有“证据”，符合逻辑的分析、看法～

---

文章会第一时间更新在[GitHub](https://github.com/YxrSadhu/Article)，觉得写得还不错的，可以点个star支持下作者🍪